package simpledb;

import java.util.*;
import java.io.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

	private JoinPredicate _predicate;
	private DbIterator _outerRelation;
	private DbIterator _innerRelation;
	private Iterator<Tuple> _outerPage = null;
	private Iterator<Tuple> _innerPage = null;

	private Tuple _outerRecent = null;
	private Tuple _innerRecent = null;

	private int _joinType = 0;
	private int _numMatches = 0;
	private int _numComp = 0;

	public static final int SNL = 0;
	public static final int PNL = 1;
	public static final int BNL = 2;
	public static final int SMJ = 3;
	public static final int HJ = 4;

	/**
	 * Constructor. Accepts to children to join and the predicate to join them
	 * on
	 *
	 * @param p
	 *            The predicate to use to join the children
	 * @param child1
	 *            Iterator for the left(outer) relation to join
	 * @param child2
	 *            Iterator for the right(inner) relation to join
	 */
	public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
		// IMPLEMENT THIS
		this._predicate = p;
		this._outerRelation = child1;
		this._innerRelation = child2;

		_outerPage = null;
		_innerPage = null;
		_outerRecent = null;
		_innerRecent = null;
	}

	public void setJoinAlgorithm(int joinAlgo) {
		_joinType = joinAlgo;
	}

	/**
	 * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible
	 *      implementation logic.
	 */
	public TupleDesc getTupleDesc() {
		// IMPLEMENT THIS
		return null;
	}

	public void open() throws DbException, NoSuchElementException, TransactionAbortedException, IOException {
		_outerRelation.open();
		_innerRelation.open();
	}

	public void close() {
		_outerRelation.close();
		_innerRelation.close();
	}

	public void rewind() throws DbException, TransactionAbortedException, IOException {
		_outerRelation.rewind();
		_innerRelation.rewind();
	}

	/**
	 * Returns the next tuple generated by the join, or null if there are no
	 * more tuples. Logically, this is the next tuple in r1 cross r2 that
	 * satisfies the join predicate. There are many possible implementations;
	 * the simplest is a nested loops join.
	 * <p>
	 * Note that the tuples returned from this particular implementation of Join
	 * are simply the concatenation of joining tuples from the left and right
	 * relation. Therefore, there will be two copies of the join attribute in
	 * the results. (Removing such duplicate columns can be done with an
	 * additional projection operator if needed.)
	 * <p>
	 * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
	 * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
	 *
	 * @return The next matching tuple.
	 * @see JoinPredicate#filter
	 */
	protected Tuple readNext() throws TransactionAbortedException, DbException {
		switch (_joinType) {
		case SNL:
			return SNL_readNext();
		case PNL:
			return PNL_readNext();
		case BNL:
			return BNL_readNext();
		case SMJ:
			return SMJ_readNext();
		case HJ:
			return HJ_readNext();
		default:
			return SNL_readNext();
		}
	}

	protected Tuple SNL_readNext() throws TransactionAbortedException, DbException {
		try {
			if (_outerRecent == null) {
				setNextOutRecentTuple();
			}
			// outer tuple stays same, and matches different inner tuples in
			// following while loop.
			if (_outerRecent != null) {
				while (_innerRelation.hasNext()) {
					_innerRecent = _innerRelation.next();
					if (_predicate.filter(_outerRecent, _innerRecent)) {
						++_numMatches;
						return joinTuple(_outerRecent, _innerRecent, createDesc(_outerRecent, _innerRecent));
					}
				}
				/**
				 * if inner loop meets end, but outer relation does not meet
				 * end, get the next outer tuple, init iterator of inner
				 * relation, finally recall this function
				 */
				if (_outerRelation.hasNext()) {
					setNextOutRecentTuple();
					_innerRelation.rewind();
					return SNL_readNext();
				} else {
					return null;
				}
			} else {
				// if outer relation does not have more tuple, just return null
				return null;
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * get outer relation tuple for SNL only (new added function)
	 * 
	 * @throws NoSuchElementException
	 * @throws DbException
	 * @throws TransactionAbortedException
	 * @throws IOException
	 */
	private void setNextOutRecentTuple()
			throws NoSuchElementException, DbException, TransactionAbortedException, IOException {
		if (_outerRelation.hasNext()) {
			_outerRecent = _outerRelation.next();
		} else {
			_outerRecent = null;
		}
	}

	protected Tuple PNL_readNext() throws TransactionAbortedException, DbException {
		// IMPLEMENT THIS (EXTRA CREDIT ONLY)
		return null;
	}

	protected Tuple BNL_readNext() throws TransactionAbortedException, DbException {
		// no need to implement this
		return null;
	}

	// used to store the previous number of same tuple
	private List<Tuple> _lInnerSameTuples = new LinkedList<Tuple>();
	private Tuple _outerLast = null;
	private Tuple _innerLast = null;

	protected Tuple SMJ_readNext() throws TransactionAbortedException, DbException {
		try {
			if (_outerRecent == null && _outerRelation.hasNext()) {
				setNextOutRecentTuple();
				_outerLast = _outerRecent;
			}
			if (_lInnerSameTuples.size() == 0) {
				// read the same tuple in inner relation for matching
				setInnerSameTuple();
			}
			// outer tuple stays same, and matches same inner tuples in
			// following loop.
			if (_outerRecent != null && _lInnerSameTuples.size() > 0) {

				Tuple tOut = _outerRecent;
				Tuple tIn = _lInnerSameTuples.get(0);
				// only when the certain fields of 2 tuples are equal, and
				// match, otherwise according to the relationship to get next
				// tuple
				while (!_predicate.filter(tOut, tIn)) {
					if (_predicate.getLeftField(tOut).compare(Predicate.Op.GREATER_THAN,
							_predicate.getLeftField(tIn))) {
						setInnerSameTuple();
						if (_lInnerSameTuples.size() == 0) {
							return null;
						}
						tIn = _lInnerSameTuples.get(0);
					} else {
						_outerLast = _outerRecent;
						setNextOutRecentTuple();
						tOut = _outerRecent;
						if (tOut == null) {
							return null;
						}
					}
				}

				while (_innerPage.hasNext()) {
					Tuple tInnerSameTuple = _innerPage.next();
					if (_predicate.filter(_outerRecent, tInnerSameTuple)) {
						//System.out.println(_outerRecent.getField(0) + ":" + tInnerSameTuple.getField(0));
						++_numMatches;
						//System.out.println(_numMatches);
						return joinTuple(_outerRecent, tInnerSameTuple, createDesc(_outerRecent, tInnerSameTuple));
					}
				}
				/**
				 * if inner loop meets end, outer tuple must move to the next.
				 * if the next out loop is same as this one, rematch this array
				 * of inner tuples again, otherwise, get new inner tuples
				 */
				if (_outerRelation.hasNext()) {
					// set the outer recent to next tuple
					_outerLast = _outerRecent;
					setNextOutRecentTuple();
					// init the iterator
					_innerPage = _lInnerSameTuples.iterator();
					return SMJ_readNext();
				} else {
					return null;
				}
			} else {
				// if outer or inner relation does not have more tuple, just
				// return null
				return null;
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * get same inner tuples at first, which is used to match one outer tuple
	 * (new added)
	 * 
	 * @throws IOException
	 * @throws TransactionAbortedException
	 * @throws DbException
	 * @throws NoSuchElementException
	 */
	private void setInnerSameTuple()
			throws NoSuchElementException, DbException, TransactionAbortedException, IOException {
		if (_innerRelation.hasNext()) {
			if (_innerRecent == null) {
				_innerRecent = _innerRelation.next();
			}
		} else {
			if (_predicate.filter(_innerRecent, _lInnerSameTuples.get(0))) {
				_lInnerSameTuples.clear();
				_innerRecent = null;
			} else {
				_lInnerSameTuples.clear();
				_lInnerSameTuples.add(_innerRecent);
				_innerPage = _lInnerSameTuples.iterator();
			}
			return;
		}
		// init linkedlist for new same tuples
		_lInnerSameTuples.clear();
		_innerLast = _innerRecent;
		while (_innerRelation.hasNext()) {
			if (_predicate.filter(_innerLast, _innerRecent)) {
				_lInnerSameTuples.add(_innerRecent);
			} else {
				break;
			}
			_innerRecent = _innerRelation.next();
		}
		if (_predicate.filter(_innerLast, _innerRecent)) {
			_lInnerSameTuples.add(_innerRecent);
		}
		_innerPage = _lInnerSameTuples.iterator();
	}

	protected Tuple HJ_readNext() throws TransactionAbortedException, DbException {
		// no need to implement this
		return null;
	}

	/**
	 * use 2 old descs to create 1 new desc (new added function)
	 * 
	 * @param outer
	 * @param inner
	 * @return
	 */
	private TupleDesc createDesc(Tuple outer, Tuple inner) {
		// get old 2 descs
		TupleDesc tdOuter = outer.getTupleDesc();
		TupleDesc tdInner = inner.getTupleDesc();

		// reconstruct a new Desc
		int nNumFields = tdOuter.numFields() + tdInner.numFields();

		Type[] fieldTypes = new Type[nNumFields];
		String[] fieldNames = new String[nNumFields];

		// set fieldTypes and fieldNames for new desc
		for (int i = 0; i < tdOuter.numFields(); i++) {
			fieldTypes[i] = tdOuter.getType(i);
			fieldNames[i] = tdOuter.getFieldName(i);
		}
		for (int i = 0; i < tdInner.numFields(); i++) {
			fieldTypes[i + tdOuter.numFields()] = tdInner.getType(i);
			fieldNames[i + tdOuter.numFields()] = tdInner.getFieldName(i);
		}

		// directly use the constructor of TupleDesc with 2 parameters
		TupleDesc tdNew = new TupleDesc(fieldTypes, fieldNames);
		return tdNew;
	}

	private Tuple joinTuple(Tuple outer, Tuple inner, TupleDesc tupledesc) {

		// copy all value from old 2 tuples to new tuple
		Tuple t = new Tuple(tupledesc);
		for (int i = 0; i < outer.getTupleDesc().numFields(); i++) {
			t.setField(i, outer.getField(i));
		}
		for (int i = 0; i < inner.getTupleDesc().numFields(); i++) {
			t.setField(i + outer.getTupleDesc().numFields(), inner.getField(i));
		}

		return t;
	}

	public int getNumMatches() {
		return _numMatches;
	}

	public int getNumComp() {
		return _numComp;
	}

}
