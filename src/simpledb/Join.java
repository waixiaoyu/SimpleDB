package simpledb;

import java.util.*;
import java.io.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

    private JoinPredicate _predicate;
    private DbIterator _outerRelation;
    private DbIterator _innerRelation;
    private Iterator<Tuple> _outerPage = null;
    private Iterator<Tuple> _innerPage = null;

    private Tuple _outerRecent = null;
    private Tuple _innerRecent = null;

    private int _joinType = 0;
    private int _numMatches = 0;
    private int _numComp = 0;

    public static final int SNL = 0;
    public static final int PNL = 1;
    public static final int BNL = 2;
    public static final int SMJ = 3;
    public static final int HJ = 4;

    /**
     * Constructor. Accepts to children to join and the predicate to join them
     * on
     *
     * @param p
     *            The predicate to use to join the children
     * @param child1
     *            Iterator for the left(outer) relation to join
     * @param child2
     *            Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
        //IMPLEMENT THIS
        this._predicate = p;
        this._outerRelation = child1;
        this._innerRelation = child2;

        _outerPage = null;
        _innerPage = null;
        _outerRecent = null;
        _innerRecent = null;
    }

    public void setJoinAlgorithm(int joinAlgo) {
        _joinType = joinAlgo;
    }

    /**
     * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible
     *      implementation logic.
     */
    public TupleDesc getTupleDesc() {
        //IMPLEMENT THIS
        return null;
    }

    public void open() throws DbException, NoSuchElementException, TransactionAbortedException, IOException {
        _outerRelation.open();
        _innerRelation.open();
    }

    public void close() {
        _outerRelation.close();
        _innerRelation.close();
    }

    public void rewind() throws DbException, TransactionAbortedException, IOException {
        _outerRelation.rewind();
        _innerRelation.rewind();
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no
     * more tuples. Logically, this is the next tuple in r1 cross r2 that
     * satisfies the join predicate. There are many possible implementations;
     * the simplest is a nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of Join
     * are simply the concatenation of joining tuples from the left and right
     * relation. Therefore, there will be two copies of the join attribute in
     * the results. (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException {
        switch (_joinType) {
        case SNL:
            return SNL_readNext();
        case PNL:
            return PNL_readNext();
        case BNL:
            return BNL_readNext();
        case SMJ:
            return SMJ_readNext();
        case HJ:
            return HJ_readNext();
        default:
            return SNL_readNext();
        }
    }

    protected Tuple SNL_readNext() throws TransactionAbortedException, DbException {
        try {
            if (_outerRecent == null) {
                setNextOutRecentTuple();
            }
            //outer tuple stays same, and matches different inner tuples in following while loop.
            if (_outerRecent != null) {
                while (_innerRelation.hasNext()) {
                    _innerRecent = _innerRelation.next();
                    if (_predicate.filter(_outerRecent, _innerRecent)) {
                        ++_numMatches;
                        return joinTuple(_outerRecent, _innerRecent, createDesc(_outerRecent, _innerRecent));
                    }
                }
                /**
                 * if inner loop meets end, but outer relation does not meet
                 * end, get the next outer tuple, init iterator of inner
                 * relation, finally recall this function
                 */
                if (_outerRelation.hasNext()) {
                    setNextOutRecentTuple();
                    _innerRelation.rewind();
                    return SNL_readNext();
                } else {
                    return null;
                }
            } else {
                //if outer relation does not have more tuple, just return null
                return null;
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return null;
    }

    /**
     * get outer relation tuple for SNL only (new added function)
     * 
     * @throws NoSuchElementException
     * @throws DbException
     * @throws TransactionAbortedException
     * @throws IOException
     */
    private void setNextOutRecentTuple() throws NoSuchElementException, DbException, TransactionAbortedException, IOException {
        if (_outerRelation.hasNext()) {
            _outerRecent = _outerRelation.next();
        } else {
            _outerRecent = null;
        }
    }

    protected Tuple PNL_readNext() throws TransactionAbortedException, DbException {
        //IMPLEMENT THIS (EXTRA CREDIT ONLY)
        return null;
    }

    protected Tuple BNL_readNext() throws TransactionAbortedException, DbException {
        //no need to implement this
        return null;
    }

    protected Tuple SMJ_readNext() throws TransactionAbortedException, DbException {

        //IMPLEMENT THIS. YOU CAN ASSUME THE JOIN PREDICATE IS ALWAYS =
        return null;
    }

    protected Tuple HJ_readNext() throws TransactionAbortedException, DbException {
        //no need to implement this
        return null;
    }

    /**
     * use 2 old descs to create 1 new desc (new added function)
     * 
     * @param outer
     * @param inner
     * @return
     */
    private TupleDesc createDesc(Tuple outer, Tuple inner) {
        //get old 2 descs
        TupleDesc tdOuter = outer.getTupleDesc();
        TupleDesc tdInner = inner.getTupleDesc();

        //reconstruct a new Desc
        int nNumFields = tdOuter.numFields() + tdInner.numFields();

        Type[] fieldTypes = new Type[nNumFields];
        String[] fieldNames = new String[nNumFields];

        //set fieldTypes and fieldNames for new desc
        for (int i = 0; i < tdOuter.numFields(); i++) {
            fieldTypes[i] = tdOuter.getType(i);
            fieldNames[i] = tdOuter.getFieldName(i);
        }
        for (int i = 0; i < tdInner.numFields(); i++) {
            fieldTypes[i + tdOuter.numFields()] = tdInner.getType(i);
            fieldNames[i + tdOuter.numFields()] = tdInner.getFieldName(i);
        }

        //directly use the constructor of TupleDesc with 2 parameters
        TupleDesc tdNew = new TupleDesc(fieldTypes, fieldNames);
        return tdNew;
    }

    private Tuple joinTuple(Tuple outer, Tuple inner, TupleDesc tupledesc) {

        //copy all value from old 2 tuples to new tuple
        Tuple t = new Tuple(tupledesc);
        for (int i = 0; i < outer.getTupleDesc().numFields(); i++) {
            t.setField(i, outer.getField(i));
        }
        for (int i = 0; i < inner.getTupleDesc().numFields(); i++) {
            t.setField(i + outer.getTupleDesc().numFields(), inner.getField(i));
        }

        return t;
    }

    public int getNumMatches() {
        return _numMatches;
    }

    public int getNumComp() {
        return _numComp;
    }

}
